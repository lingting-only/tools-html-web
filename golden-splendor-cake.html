<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Happy Birthday</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            width: 100%;
            height: 100%;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1100 0%, #000000 90%);
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 200;
            display: flex;
            gap: 15px;
            transition: opacity 0.5s;
        }

        .icon-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: 0.3s;
        }

        .icon-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        #video-container {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 100;
            width: 160px;
            height: 120px;
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.3);
            background: #000;
            transition: opacity 0.5s;
            cursor: pointer;
            display: none;
        }

        #video-container.minimized {
            width: 60px;
            height: 45px;
            opacity: 0.7;
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.8;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #skeleton-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 10;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 3;
            pointer-events: none;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            transition: opacity 0.5s;
            display: none;
        }

        #cake-upload-btn {
            pointer-events: auto;
            margin-top: 15px;
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.6);
            color: #ffd700;
            padding: 8px 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            transition: 0.3s;
            display: inline-block;
        }

        #cake-upload-btn:hover {
            background: rgba(255, 215, 0, 0.4);
            color: #fff;
        }

        .force-hide {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        h1 {
            font-weight: 300;
            letter-spacing: 4px;
            font-size: 2.5rem;
            margin: 0 0 15px 0;
            background: linear-gradient(to bottom, #fff 30%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.5));
        }

        .instructions {
            font-size: 1rem;
            color: #fff;
            line-height: 1.8;
            max-width: 320px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            border-left: 3px solid #ffd700;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .highlight {
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        #status-text {
            margin-bottom: 10px;
            font-size: 1.1rem;
            color: #fff;
            font-weight: bold;
            letter-spacing: 1px;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            background: radial-gradient(circle, rgba(30, 15, 0, 0.98) 0%, #000 100%);
            transition: opacity 1.2s ease-out;
        }

        .start-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
        }

        #start-btn {
            position: relative;
            display: none;
            padding: 20px 60px;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 1.8rem;
            font-weight: 600;
            letter-spacing: 8px;
            color: #8a6d00;
            background: linear-gradient(135deg, #ffffff 0%, #fffde7 40%, #ffd700 100%);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 60px;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.2), 0 15px 50px rgba(255, 215, 0, 0.5);
            transition: all 0.4s;
        }

        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 0 6px rgba(255, 215, 0, 0.4), 0 20px 70px rgba(255, 215, 0, 0.9);
        }

        #upload-btn {
            display: none;
            pointer-events: auto;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            padding: 12px 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: 0.3s;
            border-radius: 50px;
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #upload-btn:hover {
            background: rgba(255, 215, 0, 0.3);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        #file-input {
            display: none;
        }

        #loading-text {
            color: #ffd700;
            font-size: 1.2rem;
            letter-spacing: 3px;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from {
                opacity: 0.5;
            }

            to {
                opacity: 1;
                text-shadow: 0 0 20px #ffd700;
            }
        }

        @media screen and (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
                letter-spacing: 2px;
            }

            #ui-layer {
                top: 20px;
                left: 20px;
                width: calc(100% - 40px);
            }

            .instructions {
                font-size: 0.85rem;
                padding: 10px;
                max-width: none;
                width: 100%;
                box-sizing: border-box;
            }

            #video-container {
                top: auto;
                bottom: 20px;
                right: 20px;
                width: 100px;
                height: 75px;
            }

            #start-btn {
                padding: 15px 40px;
                font-size: 1.4rem;
            }

            #controls {
                top: 15px;
                right: 15px;
            }
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="canvas-wrapper">
        <div id="canvas-container"></div>

        <audio id="bgm" loop preload="auto">
            <source src="" type="audio/mp3">
        </audio>

        <div id="controls" style="display:none;">
            <div class="icon-btn" id="music-btn" onclick="toggleMusic()">♫</div>
            <div class="icon-btn" id="fullscreen-btn" onclick="toggleFullscreen()">⛶</div>
        </div>

        <div id="start-screen">
            <div id="loading-text">资源预加载中 (0%)...</div>
            <div class="start-controls">
                <button id="start-btn" onclick="startExperience()">开启 2026</button>
                <button id="upload-btn" onclick="document.getElementById('file-input').click()">上传照片</button>
            </div>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>

        <div id="video-container" onclick="toggleVideoSize()">
            <video id="input-video" autoplay playsinline muted></video>
            <canvas id="skeleton-canvas"></canvas>
        </div>

        <div id="ui-layer">
            <!-- <h1>2026 Golden Splendor</h1> -->
            <div id="status-text">系统就绪，请伸手</div>
            <div class="instructions">
                • <span class="highlight">握拳</span> : 聚合成蛋糕<br />
                • <span class="highlight">张开五指</span> : 散开照片墙<br />
                • <span class="highlight">向右挥动</span> : 旋转视角<br />
                • <span class="highlight">捏合手指</span> : 抓取查看照片
            </div>
            <button id="cake-upload-btn" onclick="document.getElementById('file-input').click()">+ 添加照片</button>
        </div>
    </div>

    <script type="module">
        // 导入必要的库和模块
        import * as THREE from 'three'; // Three.js 核心库
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'; // 后期处理合成器
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js'; // 渲染通道
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'; //  bloom 效果通道
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; // 环境贴图
        import { FilesetResolver, HandLandmarker } from 'https://unpkg.com/@mediapipe/tasks-vision@0.10.0'; // MediaPipe 视觉任务
        import { FontLoader } from 'three/addons/loaders/FontLoader.js'; // 字体加载器
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js'; // 文本几何体
        import TWEEN from 'https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.esm.js'; // 动画库

        // 应用配置参数
        const CONFIG = {
            goldCount: 800,      // 金色粒子数量
            silverCount: 600,    // 银色粒子数量
            gemCount: 600,       // 宝石粒子数量
            emeraldCount: 400,   // 祖母绿粒子数量
            dustCount: 2000,     // 尘埃粒子数量
            snowCount: 3000,     // 雪花粒子数量
            introParticleCount: 12000, // 开场粒子数量
            tiers: [            // 蛋糕层级配置
                { radius: 25, height: 18, yBottom: -27 }, // 底层
                { radius: 18, height: 15, yBottom: -9 },  // 中层
                { radius: 10, height: 12, yBottom: 6 }    // 顶层
            ]
        };

        // 应用状态定义
        const STATE = {
            TREE: 'tree',     // 聚合状态（蛋糕）
            SCATTER: 'scatter', // 散开状态（照片墙）
            ZOOM: 'zoom'      // 缩放状态（查看单个照片）
        };

        // 应用模式定义
        const APP_MODE = {
            INTRO: 'intro',   // 开场模式
            CAKE: 'cake'      // 蛋糕模式
        };

        // 全局状态变量
        let currentMode = APP_MODE.INTRO; // 当前应用模式
        let currentState = STATE.TREE;    // 当前状态
        let targetState = STATE.TREE;     // 目标状态

        // Three.js 核心对象
        let scene, camera, renderer, composer;
        let mainGroup = new THREE.Group();    // 主场景组
        let introGroup = new THREE.Group();   // 开场场景组
        let snowSystem, textGroup;            // 雪花系统和文本组
        let goldMesh, silverMesh, gemMesh, emeraldMesh, dustSystem; // 各种粒子网格
        let photoMeshes = [];                 // 照片网格数组
        let zoomTargetIndex = -1;             // 当前缩放目标索引

        // 逻辑数据
        let logicData = { gold: [], silver: [], gem: [], emerald: [], dust: [] };
        const dummy = new THREE.Object3D();   // 用于粒子系统的虚拟对象
        let time = 0;                         // 时间计数器

        // 开场动画相关
        let introActive = true;               // 开场动画是否激活
        let fontGlobal;                       // 全局字体对象
        let introParticles;                   // 开场粒子
        let introLogic = [];                  // 开场逻辑
        let introTimelineStep = 0;            // 开场时间线步骤
        let introTimer = 0;                   // 开场计时器
        let cachedTextTargets = {};           // 缓存的文本目标
        let isWarping = false;                // 是否正在变形

        // 手部和手势变量
        let handPos = { x: 0, y: 0 };         // 当前手部位置
        let lastHandPos = { x: 0, y: 0 };     // 上一次手部位置
        let isHandPresent = false;            // 是否检测到手部
        let rotationVelocity = { x: 0, y: 0 }; // 旋转速度

        // 音乐和全屏控制
        const bgm = document.getElementById('bgm');

        // 切换音乐播放/暂停状态
        window.toggleMusic = function () {
            if (bgm.paused) {
                bgm.play().then(() => {
                    // 播放成功，更新按钮样式
                    document.getElementById('music-btn').style.color = '#00ff00';
                    document.getElementById('music-btn').style.borderColor = '#00ff00';
                }).catch(e => console.log("Audio play failed", e));
            } else {
                // 暂停音乐，更新按钮样式
                bgm.pause();
                document.getElementById('music-btn').style.color = '#ffd700';
                document.getElementById('music-btn').style.borderColor = 'rgba(255, 215, 0, 0.5)';
            }
        };

        let isFullscreenActive = false;

        // 切换全屏状态
        window.toggleFullscreen = function () {
            const elem = document.documentElement;
            isFullscreenActive = !isFullscreenActive;
            updateUIForFullscreen(isFullscreenActive);

            if (isFullscreenActive) {
                // 进入全屏
                if (elem.requestFullscreen) elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
                else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
            } else {
                // 退出全屏
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        };

        // 更新全屏模式下的UI
        function updateUIForFullscreen(isFull) {
            const uiLayer = document.getElementById('ui-layer');
            const videoContainer = document.getElementById('video-container');
            // const controls = document.getElementById('controls');

            if (isFull) {
                // 全屏模式，隐藏UI元素
                uiLayer.classList.add('force-hide');
                videoContainer.classList.add('force-hide');
                // controls.classList.add('force-hide');
            } else {
                // 非全屏模式，显示UI元素
                uiLayer.classList.remove('force-hide');
                videoContainer.classList.remove('force-hide');
                // controls.classList.remove('force-hide');
            }
            // 调整窗口大小，确保渲染正确
            setTimeout(onWindowResize, 100);
            setTimeout(onWindowResize, 500);
        }

        // 监听全屏状态变化
        document.addEventListener('fullscreenchange', () => {
            const isFs = document.fullscreenElement || document.webkitFullscreenElement;
            if (isFs !== null) {
                isFullscreenActive = !!isFs;
                updateUIForFullscreen(isFullscreenActive);
            }
        });

        // 切换视频容器大小
        window.toggleVideoSize = function () {
            document.getElementById('video-container').classList.toggle('minimized');
        };

        // 创建纹理
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            if (type === 'sparkle') {
                // 创建闪光纹理
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 60);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.15, 'rgba(255,240,150,1)');
                grad.addColorStop(0.5, 'rgba(255,160,0,0.4)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, 128, 128);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.moveTo(cx, 0); ctx.lineTo(cx + 4, cy); ctx.lineTo(cx, 128); ctx.lineTo(cx - 4, cy);
                ctx.moveTo(0, cy); ctx.lineTo(cx, cy - 4); ctx.lineTo(128, cy); ctx.lineTo(cx, cy + 4);
                ctx.fill();
            } else if (type === 'snow') {
                // 创建雪花纹理
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 64);
                grad.addColorStop(0, 'rgba(255,250,230,0.9)');
                grad.addColorStop(0.4, 'rgba(255,215,0,0.4)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, 128, 128);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // 初始化 Three.js 场景
        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                // 添加雾效，增强深度感
                scene.fog = new THREE.FogExp2(0x050300, 0.002);

                const dims = updateDimensions();
                // 创建透视相机
                camera = new THREE.PerspectiveCamera(50, dims.width / dims.height, 0.1, 1000);

                // 根据屏幕方向调整相机位置
                const isPortrait = dims.height > dims.width;
                camera.position.set(0, 0, isPortrait ? 200 : 140);

                // 创建渲染器
                renderer = new THREE.WebGLRenderer({
                    antialias: window.devicePixelRatio < 2, // 低像素设备开启抗锯齿
                    powerPreference: "high-performance",    // 优先使用高性能GPU
                    alpha: true                            // 透明背景
                });
                renderer.setSize(dims.width, dims.height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比，提高性能
                renderer.toneMapping = THREE.ACESFilmicToneMapping; // 使用电影色调映射
                renderer.toneMappingExposure = 1.0;
                container.appendChild(renderer.domElement);

                // 创建环境贴图
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

                // 添加光源
                scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // 环境光
                // 主聚光灯
                const mainSpot = new THREE.SpotLight(0xffaa00, 250);
                mainSpot.position.set(50, 80, 50); mainSpot.penumbra = 0.5; scene.add(mainSpot);
                // 填充光
                const fillLight = new THREE.PointLight(0xffd700, 80, 200);
                fillLight.position.set(-50, 20, 50); scene.add(fillLight);

                // 创建后期处理通道
                const renderScene = new RenderPass(scene, camera);
                // 调整 Bloom 参数：降低强度，提高阈值
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(dims.width, dims.height), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.85; // 提高阈值，只让很亮的地方发光
                bloomPass.strength = 0.8;   // 降低强度，柔和光效
                bloomPass.radius = 0.5;

                // 创建合成器并添加通道
                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // 初始化场景元素
                createMaterialsAndMeshes();
                createDust();
                createGoldenSnow();
                createStarField();
                scene.add(mainGroup);

                // 初始隐藏主场景
                mainGroup.visible = false;

                // 创建开场系统
                createIntroSystem();

                // 加载字体
                const loader = new FontLoader();
                loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', async function (font) {
                    fontGlobal = font;
                    await preCalculateTargets();
                    // 隐藏加载文本，显示开始按钮
                    document.getElementById('loading-text').style.display = 'none';
                    document.getElementById('start-btn').style.display = 'inline-block';
                    document.getElementById('upload-btn').style.display = 'inline-block';
                }, undefined, function (err) {
                    console.error("字体加载失败", err);
                    document.getElementById('loading-text').innerText = "资源加载失败，请刷新重试";
                });

                // 添加窗口大小变化监听
                window.addEventListener('resize', onWindowResize);
                // 开始动画循环
                animate();
            } catch (e) {
                console.error("Three.js 初始化失败:", e);
                document.getElementById('loading-text').innerText = "初始化错误，请检查浏览器兼容性";
            }
        }

        // 预计算文本目标位置
        async function preCalculateTargets() {
            const loading = document.getElementById('loading-text');
            const texts = ["5", "4", "3", "2", "1", "2026"]; // 倒计时文本和年份

            // 根据屏幕大小调整字体大小
            const isMobile = window.innerWidth < 768;
            const yearSize = isMobile ? 20 : 55;
            const sizes = [45, 45, 45, 45, 45, yearSize]; // 前五个数字的大小相同，年份单独设置

            // 为每个文本生成目标位置
            for (let i = 0; i < texts.length; i++) {
                // 更新加载进度
                loading.innerText = `资源预加载中 (${Math.floor((i / texts.length) * 100)}%)...`;
                await new Promise(resolve => setTimeout(resolve, 10));
                // 生成并缓存文本目标位置
                cachedTextTargets[texts[i]] = generateTextTargets(texts[i], sizes[i], 10);
            }
        }

        // 生成文本目标位置
        function generateTextTargets(text, size, height) {
            // 创建文本几何体
            const textGeo = new TextGeometry(text, { font: fontGlobal, size: size, height: 2, curveSegments: 3 });
            textGeo.center(); // 居中文本
            textGeo.computeBoundingBox(); // 计算边界框
            const bounds = textGeo.boundingBox;
            const targets = [];
            const raycaster = new THREE.Raycaster(); // 用于射线检测
            const textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()); // 创建临时文本网格
            textMesh.updateMatrixWorld();

            const step = 0.8; // 采样步长
            // 在文本边界框内采样点
            for (let x = bounds.min.x; x < bounds.max.x; x += step) {
                for (let y = bounds.min.y; y < bounds.max.y; y += step) {
                    // 从前方发射射线，检测是否与文本相交
                    raycaster.set(new THREE.Vector3(x, y, 50), new THREE.Vector3(0, 0, -1));
                    const intersects = raycaster.intersectObject(textMesh);
                    if (intersects.length > 0) {
                        // 如果相交，添加目标位置
                        targets.push(new THREE.Vector3(x, y, (Math.random() - 0.5) * height));
                        // 随机添加一些额外的点，增加密度
                        if (Math.random() > 0.5) targets.push(new THREE.Vector3(x, y, (Math.random() - 0.5) * height));
                    }
                }
            }
            textGeo.dispose(); // 释放几何体资源
            const finalTargets = [];
            // 确保生成足够的目标点
            for (let i = 0; i < CONFIG.introParticleCount; i++) {
                if (i < targets.length) finalTargets.push(targets[i]);
                else finalTargets.push(new THREE.Vector3((Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400, (Math.random() - 0.5) * 200));
            }
            // 随机排序目标点
            return finalTargets.sort(() => Math.random() - 0.5);
        }

        // 创建开场动画系统
        function createIntroSystem() {
            const geo = new THREE.BufferGeometry(); // 创建缓冲区几何体
            // 初始化各种属性数组
            const positions = []; // 位置
            const colors = [];    // 颜色
            const sizes = [];     // 大小
            const flash = [];     // 闪烁
            const velocities = []; // 速度
            // 定义两种颜色：金色和白色
            const color1 = new THREE.Color(0xffd700);
            const color2 = new THREE.Color(0xffffff);

            // 为每个粒子初始化属性
            for (let i = 0; i < CONFIG.introParticleCount; i++) {
                // 随机初始位置
                positions.push((Math.random() - 0.5) * 300, (Math.random() - 0.5) * 300, (Math.random() - 0.5) * 100);
                velocities.push(0, 0, 0); // 初始速度为0
                // 随机选择颜色
                const c = Math.random() > 0.3 ? color1 : color2;
                colors.push(c.r * 3.0, c.g * 2.5, c.b * 1.5); // 增强颜色亮度
                sizes.push(1.0 + Math.random() * 2.5); // 随机大小
                flash.push(Math.random() * Math.PI); // 随机闪烁相位

                // 添加到开场逻辑数组
                introLogic.push({
                    currentPos: new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]),
                    targetPos: new THREE.Vector3(0, 0, 0)
                });
            }

            // 设置几何体属性
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('flash', new THREE.Float32BufferAttribute(flash, 1));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            // 创建粒子材质
            const mat = new THREE.PointsMaterial({
                size: 1.5,            // 粒子大小
                vertexColors: true,   // 使用顶点颜色
                map: createTexture('sparkle'), // 使用闪光纹理
                blending: THREE.AdditiveBlending, //  additive混合模式
                depthWrite: false,    // 禁用深度写入
                transparent: true,    // 透明
                opacity: 1.0,         // 不透明度
                toneMapped: false     // 禁用色调映射
            });

            // 创建粒子系统
            introParticles = new THREE.Points(geo, mat);
            introGroup.add(introParticles); // 添加到开场组
            scene.add(introGroup); // 添加到场景
        }

        // 应用目标位置
        function applyTargets(key) {
            const targets = cachedTextTargets[key]; // 获取缓存的目标位置
            if (!targets) return; // 如果没有目标位置，直接返回
            // 为每个粒子设置目标位置
            for (let i = 0; i < CONFIG.introParticleCount; i++) {
                introLogic[i].targetPos.copy(targets[i]);
            }
        }

        // 开始体验
        window.startExperience = function () {
            // 隐藏开始屏幕
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => { document.getElementById('start-screen').style.display = 'none'; }, 1200);

            // 播放背景音乐
            bgm.volume = 0.5;
            bgm.play().then(() => {
                // 播放成功，更新音乐按钮样式
                document.getElementById('music-btn').style.color = '#00ff00';
                document.getElementById('music-btn').style.borderColor = '#00ff00';
            }).catch(() => { });

            // 开始倒计时动画
            introTimelineStep = 1; // 设置时间线步骤为1
            applyTargets("5"); // 应用数字5的目标位置
            introTimer = Date.now(); // 重置计时器
        };

        // 更新开场动画
        function updateIntro() {
            // 如果不是开场模式、时间线步骤为0或开场不活跃，直接返回
            if (currentMode !== APP_MODE.INTRO || introTimelineStep === 0 || !introActive) return;
            const now = Date.now();
            const elapsed = now - introTimer; // 计算经过的时间

            // 时间线控制
            if (introTimelineStep === 1 && elapsed > 1000) { introTimelineStep = 2; applyTargets("4"); introTimer = now; }
            else if (introTimelineStep === 2 && elapsed > 1000) { introTimelineStep = 3; applyTargets("3"); introTimer = now; }
            else if (introTimelineStep === 3 && elapsed > 1000) { introTimelineStep = 4; applyTargets("2"); introTimer = now; }
            else if (introTimelineStep === 4 && elapsed > 1000) { introTimelineStep = 5; applyTargets("1"); introTimer = now; }
            else if (introTimelineStep === 5 && elapsed > 1000) {
                introTimelineStep = 6; applyTargets("2026"); introTimer = now;
                // 相机移动动画
                new TWEEN.Tween(camera.position).to({ z: 160 }, 2000).easing(TWEEN.Easing.Cubic.Out).start();
            }
            else if (introTimelineStep === 6 && elapsed > 2500) { introTimelineStep = 7; triggerWarpEffect(); }

            // 获取粒子属性数组
            const positions = introParticles.geometry.attributes.position.array;
            const sizes = introParticles.geometry.attributes.size.array;
            const flash = introParticles.geometry.attributes.flash.array;
            const vels = introParticles.geometry.attributes.velocity.array;

            // 更新每个粒子
            for (let i = 0; i < CONFIG.introParticleCount; i++) {
                const p = introLogic[i];
                if (isWarping) {
                    // 变形效果
                    p.currentPos.x += vels[i * 3]; p.currentPos.y += vels[i * 3 + 1]; p.currentPos.z += vels[i * 3 + 2];
                    vels[i * 3 + 2] *= 1.05; vels[i * 3] *= 1.01; vels[i * 3 + 1] *= 1.01;
                } else {
                    // 正常移动到目标位置
                    const lerpFactor = (introTimelineStep === 6) ? 0.05 : 0.1;
                    p.currentPos.x += (p.targetPos.x - p.currentPos.x) * lerpFactor;
                    p.currentPos.y += (p.targetPos.y - p.currentPos.y) * lerpFactor;
                    p.currentPos.z += (p.targetPos.z - p.currentPos.z) * lerpFactor;
                    // 年份显示时添加一些随机抖动
                    if (introTimelineStep === 6) { p.currentPos.x += (Math.random() - 0.5) * 0.2; p.currentPos.y += (Math.random() - 0.5) * 0.2; }
                }
                // 更新粒子位置
                positions[i * 3] = p.currentPos.x; positions[i * 3 + 1] = p.currentPos.y; positions[i * 3 + 2] = p.currentPos.z;
                // 更新粒子大小，添加闪烁效果
                sizes[i] = (1.5 + Math.sin(time * 8 + flash[i]) * 0.8) * (introTimelineStep === 6 ? 1.8 : 1);
            }
            // 标记属性需要更新
            introParticles.geometry.attributes.position.needsUpdate = true;
            introParticles.geometry.attributes.size.needsUpdate = true;
        }

        // 触发变形效果
        function triggerWarpEffect() {
            isWarping = true; // 标记为变形状态
            const vels = introParticles.geometry.attributes.velocity.array;
            // 为每个粒子设置随机速度
            for (let i = 0; i < CONFIG.introParticleCount; i++) {
                vels[i * 3] = (Math.random() - 0.5) * 1.5; // x 方向速度
                vels[i * 3 + 1] = (Math.random() - 0.5) * 1.5; // y 方向速度
                vels[i * 3 + 2] = 2.0 + Math.random() * 5.0; // z 方向速度（向前）
            }

            // 相机向前移动
            new TWEEN.Tween(camera.position).to({ z: 100 }, 2000).easing(TWEEN.Easing.Quadratic.In).start();

            // 显示主场景并添加缩放动画
            setTimeout(() => {
                mainGroup.visible = true;
                mainGroup.scale.set(0.001, 0.001, 0.001); // 初始缩放到很小

                // 主场景缩放动画
                new TWEEN.Tween(mainGroup.scale)
                    .to({ x: 1, y: 1, z: 1 }, 3500)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();

                // 主场景旋转动画
                new TWEEN.Tween(mainGroup.rotation)
                    .to({ y: 0 }, 3500)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            }, 500);

            // 完成开场动画
            setTimeout(finishIntro, 1000);
        }

        // 完成开场动画
        function finishIntro() {
            // 淡出开场粒子
            new TWEEN.Tween(introParticles.material)
                .to({ opacity: 0 }, 1000)
                .onComplete(() => {
                    introActive = false;
                    scene.remove(introGroup); // 从场景中移除开场组
                })
                .start();

            // 调整相机位置
            const dims = updateDimensions();
            const finalZ = (dims.height > dims.width) ? 200 : 140;

            new TWEEN.Tween(camera.position).to({ z: finalZ }, 2500).easing(TWEEN.Easing.Cubic.Out).start();

            // 切换到蛋糕模式
            currentMode = APP_MODE.CAKE;
            mainGroup.rotation.y = Math.PI * 1; // 初始旋转角度

            // 显示UI元素
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('controls').style.display = 'flex';
            document.getElementById('video-container').style.display = 'block';
            createHeaderText(); // 创建标题文本

            // 启动 MediaPipe 手部检测
            setTimeout(() => {
                document.getElementById('status-text').innerText = "系统就绪，正在启动视觉...";
                setupMediaPipe();
            }, 500);
        }

        // 创建金色雪花系统
        function createGoldenSnow() {
            const geo = new THREE.BufferGeometry(); // 创建缓冲区几何体
            const pos = [];     // 位置数组
            const speeds = [];  // 速度数组
            const sizes = [];   // 大小数组

            // 初始化雪花属性
            for (let i = 0; i < CONFIG.snowCount; i++) {
                // 随机位置
                pos.push((Math.random() - 0.5) * 350, (Math.random() - 0.5) * 350, (Math.random() - 0.5) * 250);
                // 随机速度
                speeds.push(0.02 + Math.random() * 0.08);
                // 随机大小
                sizes.push(2.0 + Math.random() * 4.0);
            }

            // 设置几何体属性
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // 创建雪花材质
            const mat = new THREE.PointsMaterial({
                color: 0xffeebb,       // 金色
                size: 1.0,             // 基础大小
                map: createTexture('snow'), // 雪花纹理
                transparent: true,     // 透明
                opacity: 0.6,          // 不透明度
                blending: THREE.AdditiveBlending, // additive混合模式
                depthWrite: false      // 禁用深度写入
            });

            // 创建雪花系统
            snowSystem = new THREE.Points(geo, mat);
            snowSystem.userData = { speeds: speeds }; // 存储速度数据
            scene.add(snowSystem); // 添加到场景
        }

        // 更新雪花系统
        function updateSnow() {
            if (!snowSystem) return; // 如果雪花系统不存在，直接返回
            const positions = snowSystem.geometry.attributes.position.array;
            const speeds = snowSystem.userData.speeds;

            // 更新每个雪花
            for (let i = 0; i < CONFIG.snowCount; i++) {
                positions[i * 3 + 1] -= speeds[i]; // 雪花下落
                positions[i * 3] += Math.sin(time * 0.5 + i) * 0.05; // 左右摇摆

                // 雪花超出边界后重置位置
                if (positions[i * 3 + 1] < -120) {
                    positions[i * 3 + 1] = 120; // 重置到顶部
                    positions[i * 3] = (Math.random() - 0.5) * 350; // 随机x位置
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 250; // 随机z位置
                }
            }

            // 标记位置属性需要更新
            snowSystem.geometry.attributes.position.needsUpdate = true;
            // 雪花系统缓慢旋转
            snowSystem.rotation.y = time * 0.01;
        }

        // 创建标题文本
        function createHeaderText() {
            // 创建画布
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 2048; textCanvas.height = 512;
            const ctx = textCanvas.getContext('2d');
            ctx.clearRect(0, 0, 2048, 512); // 清空画布

            // 设置字体样式
            ctx.font = '900 200px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

            // 绘制文字描边
            ctx.strokeStyle = 'rgba(255, 180, 0, 0.9)'; ctx.lineWidth = 6;
            ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 40;
            ctx.strokeText('小芳 生日快乐', 1024, 256);

            // 创建渐变填充
            const gradient = ctx.createLinearGradient(0, 100, 0, 400);
            gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(0.3, '#ffd700');
            gradient.addColorStop(0.7, '#ff8c00'); gradient.addColorStop(1, '#8b4500');
            ctx.fillStyle = gradient; ctx.shadowBlur = 0;
            ctx.fillText('小芳 生日快乐', 1024, 256);

            // 创建纹理
            const textTex = new THREE.CanvasTexture(textCanvas);
            textTex.colorSpace = THREE.SRGBColorSpace;

            // 创建材质
            const textMat = new THREE.MeshBasicMaterial({
                map: textTex, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
            });

            // 创建平面几何体
            const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(90, 22.5), textMat);

            // 计算文本位置（蛋糕顶部）
            const topTier = CONFIG.tiers[CONFIG.tiers.length - 1];
            const textY = topTier.yBottom + topTier.height + 20;
            textPlane.position.set(0, textY, 0);

            // 添加到场景
            textGroup = textPlane;
            mainGroup.add(textGroup);

            // 添加上下浮动动画
            new TWEEN.Tween(textGroup.position).to({ y: textY + 4 }, 2500).yoyo(true).repeat(Infinity).easing(TWEEN.Easing.Sinusoidal.InOut).start();
        }

        // 更新尺寸
        function updateDimensions() {
            const width = window.innerWidth; // 获取窗口宽度
            const height = window.innerHeight; // 获取窗口高度
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = width + 'px'; // 设置包装器宽度
            wrapper.style.height = height + 'px'; // 设置包装器高度
            return { width, height }; // 返回尺寸对象
        }

        // 创建星形几何体
        function createStarGeometry() {
            const shape = new THREE.Shape(); // 创建形状
            const outerRadius = 3.5; // 外半径
            const innerRadius = 1.6; // 内半径
            const points = 5; // 五角星

            // 生成五角星顶点
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points; // 计算角度
                const radius = i % 2 === 0 ? outerRadius : innerRadius; // 交替使用内外半径
                const x = Math.cos(angle) * radius; // 计算x坐标
                const y = Math.sin(angle) * radius; // 计算y坐标
                if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y); // 绘制路径
            }
            shape.closePath(); // 闭合路径

            // 创建拉伸几何体并返回
            return new THREE.ExtrudeGeometry(shape, {
                steps: 1, // 拉伸步数
                depth: 0.8, // 厚度
                bevelEnabled: true, // 启用倒角
                bevelThickness: 0.3, // 倒角厚度
                bevelSize: 0.3, // 倒角大小
                bevelSegments: 3 // 倒角分段
            });
        }

        // 创建材质和网格
        function createMaterialsAndMeshes() {
            // 降低自发光强度，配合 Bloom 调整
            // 创建金色材质
            const goldMat = new THREE.MeshPhysicalMaterial({
                color: 0xffcc00,        // 金色
                metalness: 1.0,         // 金属度
                roughness: 0.1,         // 粗糙度
                clearcoat: 1.0,         // 清漆
                emissive: 0xffaa00,     // 自发光颜色
                emissiveIntensity: 0.8  // 自发光强度
            });

            // 创建银色材质
            const silverMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,        // 银色
                metalness: 0.3,         // 金属度
                roughness: 0.1,         // 粗糙度
                transmission: 0.2,      // 透射率
                emissive: 0x444444,     // 自发光颜色
                emissiveIntensity: 0.2  // 自发光强度
            });

            // 创建宝石红材质
            const gemMat = new THREE.MeshPhysicalMaterial({
                color: 0xff0044,        // 宝石红
                metalness: 0.1,         // 金属度
                roughness: 0.0,         // 粗糙度
                transmission: 0.8,      // 透射率
                thickness: 2.0,         // 厚度
                emissive: 0xaa0022,     // 自发光颜色
                emissiveIntensity: 0.8  // 自发光强度
            });

            // 创建祖母绿材质
            const emeraldMat = new THREE.MeshPhysicalMaterial({
                color: 0x00ccff,        // 祖母绿
                metalness: 0.2,         // 金属度
                roughness: 0.1,         // 粗糙度
                transmission: 0.5,      // 透射率
                thickness: 1.5,         // 厚度
                emissive: 0x004488,     // 自发光颜色
                emissiveIntensity: 0.8  // 自发光强度
            });

            // 创建实例化网格
            goldMesh = createInstancedMesh(new THREE.SphereGeometry(0.7, 16, 16), goldMat, CONFIG.goldCount, logicData.gold);
            silverMesh = createInstancedMesh(new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16), silverMat, CONFIG.silverCount, logicData.silver);
            gemMesh = createInstancedMesh(new THREE.SphereGeometry(0.8, 16, 16), gemMat, CONFIG.gemCount, logicData.gem);
            emeraldMesh = createInstancedMesh(new THREE.ConeGeometry(0.5, 1.2, 8), emeraldMat, CONFIG.emeraldCount, logicData.emerald);

            // 创建星星
            const starGeo = createStarGeometry();
            starGeo.center();
            const star = new THREE.Mesh(starGeo, new THREE.MeshPhysicalMaterial({
                color: 0xffd700,        // 金色
                metalness: 1.0,         // 金属度
                roughness: 0.0,         // 粗糙度
                emissive: 0xffaa00,     // 自发光颜色
                emissiveIntensity: 2.5  // 自发光强度
            }));

            // 计算星星位置
            const topTier = CONFIG.tiers[CONFIG.tiers.length - 1];
            const topY = topTier.yBottom + topTier.height + 4;
            star.userData = {
                treePos: new THREE.Vector3(0, topY, 0),     // 树上位置
                scatterPos: new THREE.Vector3(0, 60, 0)     // 散射位置
            };
            star.position.copy(star.userData.treePos);

            // 添加点光源
            star.add(new THREE.PointLight(0xffaa00, 80, 50));
            mainGroup.add(star);
            logicData.star = star;
        }

        // 创建实例化网格
        function createInstancedMesh(geo, mat, count, dataArray) {
            // 创建实例化网格
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            // 设置实例矩阵为动态绘制
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            // 添加到主组
            mainGroup.add(mesh);

            // 为每个实例生成数据
            for (let i = 0; i < count; i++) {
                // 随机选择蛋糕层
                const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length);
                const tier = CONFIG.tiers[tierIndex];
                // 随机高度
                const h = Math.random() * tier.height;
                // 随机半径（使用平方根分布使分布更均匀）
                const r = Math.sqrt(Math.random()) * tier.radius;
                // 30% 的概率使用蛋糕层边缘位置
                let finalR = r;
                if (Math.random() > 0.3) {
                    finalR = tier.radius * (0.9 + Math.random() * 0.15);
                }
                // 随机角度
                const theta = Math.random() * Math.PI * 2;
                // 计算位置
                const treePos = new THREE.Vector3(
                    finalR * Math.cos(theta), // x坐标
                    tier.yBottom + h,         // y坐标
                    finalR * Math.sin(theta)  // z坐标
                );

                // 添加到数据数组
                dataArray.push({
                    treePos: treePos,                         // 树上位置
                    scatterPos: randomSpherePoint(40 + Math.random() * 40), // 散射位置
                    currentPos: treePos.clone(),              // 当前位置
                    scale: 0.6 + Math.random() * 0.8,         // 缩放
                    rotSpeed: new THREE.Euler(Math.random() * 0.03, Math.random() * 0.03, Math.random() * 0.03), // 旋转速度
                    rotation: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, 0), // 初始旋转
                    tierIndex: tierIndex                      // 蛋糕层索引
                });
            }
            return mesh;
        }

        // 生成球体上的随机点
        function randomSpherePoint(r) {
            const u = Math.random(); // 随机参数 u
            const v = Math.random(); // 随机参数 v
            const theta = 2 * Math.PI * u; // 方位角
            const phi = Math.acos(2 * v - 1); // 极角
            // 转换为笛卡尔坐标
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta), // x坐标
                r * Math.sin(phi) * Math.sin(theta), // y坐标
                r * Math.cos(phi)                    // z坐标
            );
        }

        // 创建尘埃粒子
        function createDust() {
            const geo = new THREE.BufferGeometry(); // 创建缓冲区几何体
            const pos = []; // 位置数组

            // 生成尘埃粒子
            for (let i = 0; i < CONFIG.dustCount; i++) {
                // 随机选择蛋糕层
                const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length);
                const tier = CONFIG.tiers[tierIndex];
                // 随机半径（稍大于蛋糕层半径）
                const r = tier.radius * (1.0 + Math.random() * 0.2);
                // 随机角度
                const theta = Math.random() * Math.PI * 2;
                // 计算位置
                const x = r * Math.cos(theta);
                const y = tier.yBottom + Math.random() * tier.height;
                const z = r * Math.sin(theta);
                // 添加位置
                pos.push(x, y, z);
                // 添加到逻辑数据
                logicData.dust.push({
                    treePos: new THREE.Vector3(x, y, z),       // 树上位置
                    scatterPos: randomSpherePoint(60),         // 散射位置
                    currentPos: new THREE.Vector3(x, y, z),    // 当前位置
                    tierIndex: tierIndex                      // 蛋糕层索引
                });
            }

            // 设置位置属性
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

            // 创建尘埃系统
            dustSystem = new THREE.Points(geo, new THREE.PointsMaterial({
                color: 0xffccaa,     // 金色
                size: 0.8,           // 大小
                transparent: true,   // 透明
                opacity: 0.6,        // 不透明度
                blending: THREE.AdditiveBlending, // additive blending
                depthWrite: false    // 关闭深度写入
            }));

            // 添加到主组
            mainGroup.add(dustSystem);
        }

        // 创建星空背景
        function createStarField() {
            const geo = new THREE.BufferGeometry(); // 创建缓冲区几何体
            const pos = []; // 位置数组

            // 生成800个星星
            for (let i = 0; i < 800; i++) {
                // 生成随机位置（-500到500之间）
                pos.push(
                    (Math.random() - 0.5) * 1000, // x坐标
                    (Math.random() - 0.5) * 1000, // y坐标
                    (Math.random() - 0.5) * 1000  // z坐标
                );
            }

            // 设置位置属性
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

            // 创建星星材质
            const mat = new THREE.PointsMaterial({
                color: 0xffddaa,     // 暖白色
                size: 1.5,           // 大小
                transparent: true,   // 透明
                opacity: 0.4         // 不透明度
            });

            // 创建星星点云并添加到场景
            scene.add(new THREE.Points(geo, mat));
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate); // 请求下一帧
            TWEEN.update(); // 更新 TWEEN 动画
            time += 0.01; // 时间增量

            if (currentMode === APP_MODE.INTRO) {
                // 介绍模式
                if (introActive) updateIntro(); // 更新介绍动画
                updateSnow(); // 更新雪花
            } else {
                // 主模式
                // 更新各种实例化网格
                updateInstancedMesh(goldMesh, logicData.gold);
                updateInstancedMesh(silverMesh, logicData.silver);
                updateInstancedMesh(gemMesh, logicData.gem);
                updateInstancedMesh(emeraldMesh, logicData.emerald);
                updateDust(); // 更新尘埃
                updatePhotos(); // 更新照片
                updateSnow(); // 更新雪花

                // 更新星星
                if (logicData.star) {
                    // 根据当前状态选择目标位置
                    let target = currentState === STATE.TREE ? logicData.star.userData.treePos : logicData.star.userData.scatterPos;
                    logicData.star.position.lerp(target, 0.1); // 平滑过渡到目标位置
                    logicData.star.position.y += Math.sin(time * 2) * 0.03; // 上下浮动
                    logicData.star.rotation.y += 0.02; // 旋转
                }

                // 更新文本
                if (textGroup) {
                    textGroup.lookAt(camera.position); // 始终面向相机
                    const targetOpacity = (currentState === STATE.TREE) ? 1.0 : 0.0; // 树状态时显示文本
                    textGroup.material.opacity += (targetOpacity - textGroup.material.opacity) * 0.1; // 平滑过渡透明度
                }

                // 更新旋转速度
                if (currentState === STATE.ZOOM) {
                    // 缩放状态时停止旋转
                    rotationVelocity.x = 0; rotationVelocity.y = 0;
                } else if (currentState === STATE.SCATTER) {
                    // 散射状态时根据手部移动旋转
                    if (isHandPresent) {
                        const deltaX = handPos.x - lastHandPos.x; // 手部x方向移动
                        const deltaY = handPos.y - lastHandPos.y; // 手部y方向移动

                        // 只允许向右滑动
                        if (deltaX > 0.001) rotationVelocity.y += deltaX * 0.2;
                        if (Math.abs(deltaY) > 0.001) rotationVelocity.x += deltaY * 0.08;
                        lastHandPos.x = handPos.x; lastHandPos.y = handPos.y;
                    }
                    // 限制旋转速度
                    rotationVelocity.y = Math.min(Math.max(rotationVelocity.y, -0.1), 0.1);
                    rotationVelocity.x = Math.min(Math.max(rotationVelocity.x, -0.05), 0.05);

                    mainGroup.rotation.y += rotationVelocity.y; // 应用旋转速度
                    mainGroup.rotation.x += rotationVelocity.x;

                    // 旋转速度衰减
                    rotationVelocity.y *= 0.95;
                    rotationVelocity.x *= 0.92;
                    mainGroup.rotation.x *= 0.95;
                } else if (currentState === STATE.TREE) {
                    // 树状态时缓慢旋转
                    mainGroup.rotation.y += 0.003;
                    mainGroup.rotation.x *= 0.95;
                }
            }
            composer.render(); // 渲染场景
        }

        // 更新实例化网格
        function updateInstancedMesh(mesh, dataArray) {
            const isMobile = window.innerWidth < 768; // 判断是否为移动设备
            const lerpFactor = isMobile ? 0.25 : 0.1; // 移动设备使用更快的过渡速度

            // 遍历每个实例
            for (let i = 0; i < dataArray.length; i++) {
                const item = dataArray[i];
                // 根据当前状态选择目标位置
                let target = currentState === STATE.TREE ? item.treePos : item.scatterPos;
                if (currentState === STATE.ZOOM) target = item.scatterPos; // 缩放状态时使用散射位置
                // 散射状态时添加上下浮动
                if (currentState === STATE.SCATTER) item.currentPos.y += Math.sin(time + i) * 0.005;

                // 平滑过渡到目标位置
                item.currentPos.lerp(target, lerpFactor);

                // 更新旋转
                item.rotation.x += item.rotSpeed.x; item.rotation.y += item.rotSpeed.y;
                // 计算缩放
                let s = item.scale;
                if (currentState === STATE.ZOOM) s = item.scale * 0.6; // 缩放状态时缩小

                // 更新虚拟对象矩阵
                dummy.position.copy(item.currentPos);
                dummy.rotation.copy(item.rotation);
                dummy.scale.setScalar(s);
                dummy.updateMatrix();
                // 设置实例矩阵
                mesh.setMatrixAt(i, dummy.matrix);
            }
            // 标记实例矩阵需要更新
            mesh.instanceMatrix.needsUpdate = true;
        }

        // 更新尘埃粒子
        function updateDust() {
            const isMobile = window.innerWidth < 768; // 判断是否为移动设备
            const lerpFactor = isMobile ? 0.25 : 0.1; // 移动设备使用更快的过渡速度
            const positions = dustSystem.geometry.attributes.position.array; // 获取位置数组

            // 遍历每个尘埃粒子
            for (let i = 0; i < logicData.dust.length; i++) {
                const item = logicData.dust[i];
                // 根据当前状态选择目标位置
                let target = currentState === STATE.TREE ? item.treePos : item.scatterPos;

                if (currentState !== STATE.TREE) {
                    // 非树状态时，平滑过渡到目标位置
                    item.currentPos.lerp(target, lerpFactor);
                } else {
                    // 树状态时，尘埃粒子缓慢上升
                    item.currentPos.y += 0.05;
                    const tier = CONFIG.tiers[item.tierIndex];
                    // 超出蛋糕层高度后重置
                    if (item.currentPos.y > tier.yBottom + tier.height) item.currentPos.y = tier.yBottom;
                    // 限制在蛋糕层范围内
                    if (Math.sqrt(item.currentPos.x ** 2 + item.currentPos.z ** 2) > tier.radius * 1.3) {
                        item.currentPos.x *= 0.98; item.currentPos.z *= 0.98;
                    }
                }
                // 更新位置数组
                positions[i * 3] = item.currentPos.x;
                positions[i * 3 + 1] = item.currentPos.y;
                positions[i * 3 + 2] = item.currentPos.z;
            }
            // 标记位置属性需要更新
            dustSystem.geometry.attributes.position.needsUpdate = true;
        }

        // 更新照片
        function updatePhotos() {
            const isMobile = window.innerWidth < 768; // 判断是否为移动设备
            const lerpFactor = isMobile ? 0.25 : 0.1; // 移动设备使用更快的过渡速度

            // 遍历每个照片网格
            photoMeshes.forEach((mesh, idx) => {
                let targetPos, targetScale = 2.0;

                if (currentState === STATE.TREE) {
                    // 树状态时，照片隐藏在蛋糕内
                    targetPos = mesh.userData.treePos;
                    targetScale = 0;
                } else if (currentState === STATE.SCATTER) {
                    // 散射状态时，照片散落在周围
                    targetPos = mesh.userData.scatterPos;
                    targetScale = 4.0;
                    mesh.position.y += Math.sin(time + idx) * 0.01; // 上下浮动
                    mesh.lookAt(camera.position); // 始终面向相机
                } else if (currentState === STATE.ZOOM) {
                    // 缩放状态时
                    if (idx === zoomTargetIndex) {
                        // 当前选中的照片
                        const offset = new THREE.Vector3(0, 0, -20);
                        offset.applyMatrix4(camera.matrixWorld);
                        targetPos = mainGroup.worldToLocal(offset); // 计算目标位置
                        targetScale = 2.0;
                        mesh.lookAt(camera.position); // 始终面向相机
                        if (mesh.material.emissive) mesh.material.emissive.setHex(0x000000); // 关闭自发光
                    } else {
                        // 其他照片
                        targetPos = mesh.userData.scatterPos;
                        targetScale = 3.0;
                        mesh.lookAt(camera.position); // 始终面向相机
                        if (mesh.material.emissive) mesh.material.emissive.setHex(0x222222); // 开启自发光
                    }
                }

                if (currentState === STATE.TREE) {
                    mesh.rotation.y += 0.01; // 树状态时缓慢旋转
                }

                // 平滑过渡到目标位置和缩放
                mesh.position.lerp(targetPos, lerpFactor);
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), lerpFactor);
            });
        }

        let globalHandLandmarker = null; // 全局 HandPose 模型
        let globalVideo = null; // 全局视频元素
        let detectionFrameId = null; // 检测帧 ID

        // 初始化手势识别模型
        async function setupMediaPipe() {
            try {
                // 加载模型
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                globalHandLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO", numHands: 1
                });
                // 获取视频元素
                globalVideo = document.getElementById("input-video");
                // 启动摄像头
                startCamera();
            } catch (error) {
                console.error("模型加载失败:", error);
                document.getElementById('status-text').innerText = "手势检测模型加载失败，请刷新页面重试";
            }
        }

        // 启动摄像头
        function startCamera() {
            if (!globalVideo) return; // 视频元素不存在，直接返回

            // 清除之前的检测帧
            if (detectionFrameId) {
                cancelAnimationFrame(detectionFrameId);
                detectionFrameId = null;
            }

            // 停止之前的摄像头流
            if (globalVideo.srcObject) {
                globalVideo.srcObject.getTracks().forEach(track => track.stop());
                globalVideo.srcObject = null;
            }

            // 摄像头约束
            const constraints = {
                video: {
                    facingMode: "user", // 使用前置摄像头
                    width: { ideal: 640 }, // 理想宽度
                    height: { ideal: 480 } // 理想高度
                }
            };

            // 请求摄像头权限
            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                globalVideo.srcObject = stream; // 设置视频源
                globalVideo.play().then(() => {
                    predictWebcam(); // 开始手势检测
                });
            }).catch(err => {
                console.error("Camera failed: ", err);
                document.getElementById('status-text').innerText = "摄像头启动失败";
            });
        }

        let lastPredictionTime = -1; // 上次预测时间

        // 手势检测核心函数
        async function predictWebcam() {
            // 检查视频是否可用
            if (!globalVideo || globalVideo.paused || globalVideo.ended) {
                detectionFrameId = requestAnimationFrame(predictWebcam);
                return;
            }

            // 控制检测频率（每50ms一次）
            let startTimeMs = performance.now();
            if (startTimeMs - lastPredictionTime < 50) {
                detectionFrameId = requestAnimationFrame(predictWebcam);
                return;
            }

            lastPredictionTime = startTimeMs;

            try {
                // 使用 TensorFlow.js HandPose 模型检测手部
                const result = await globalHandLandmarker.detectForVideo(globalVideo, startTimeMs);
                const canvas = document.getElementById('skeleton-canvas');
                const ctx = canvas.getContext('2d');
                // 调整画布大小
                if (canvas.width !== globalVideo.videoWidth) {
                    canvas.width = globalVideo.videoWidth;
                    canvas.height = globalVideo.videoHeight;
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空画布

                if (result.landmarks && result.landmarks.length > 0) {
                    const landmarks = result.landmarks[0];
                    isHandPresent = true;
                    drawSkeleton(ctx, landmarks, canvas.width, canvas.height); // 绘制骨架
                    handleGesture(landmarks); // 处理手势
                } else {
                    isHandPresent = false;
                }
            } catch (e) {
                console.error("检测错误:", e);
            }

            // 请求下一帧
            detectionFrameId = requestAnimationFrame(predictWebcam);
        }

        // 绘制手部骨架
        function drawSkeleton(ctx, landmarks, w, h) {
            ctx.lineWidth = 3; // 线条宽度
            ctx.strokeStyle = '#ffd700'; // 线条颜色（金色）
            ctx.fillStyle = '#ff3300'; // 填充颜色（红色）

            // 手部骨骼连接
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // 拇指
                [0, 5], [5, 6], [6, 7], [7, 8], // 食指
                [5, 9], [9, 10], [10, 11], [11, 12], // 中指
                [9, 13], [13, 14], [14, 15], [15, 16], // 无名指
                [13, 17], [17, 18], [18, 19], [19, 20], // 小指
                [0, 17] // 手掌
            ];

            // 绘制骨骼线
            ctx.beginPath();
            for (let i = 0; i < connections.length; i++) {
                const start = landmarks[connections[i][0]]; // 起点
                const end = landmarks[connections[i][1]]; // 终点
                ctx.moveTo(start.x * w, start.y * h); // 移动到起点
                ctx.lineTo(end.x * w, end.y * h); // 绘制到终点
            }
            ctx.stroke(); // 描边

            // 绘制关节点
            for (let i = 0; i < landmarks.length; i++) {
                ctx.beginPath();
                ctx.arc(landmarks[i].x * w, landmarks[i].y * h, 4, 0, 2 * Math.PI); // 绘制圆形
                ctx.fill(); // 填充
            }
        }

        // 处理手势
        function handleGesture(landmarks) {
            // 计算手掌中心位置
            const palmX = 1 - (landmarks[0].x + landmarks[9].x) / 2; // 手腕和中指根部的中点
            const palmY = (landmarks[0].y + landmarks[9].y) / 2;
            // 平滑更新手部位置
            handPos.x = handPos.x * 0.8 + palmX * 0.2;
            handPos.y = handPos.y * 0.8 + palmY * 0.2;

            // 检测手指是否弯曲
            let folded = 0;
            [8, 12, 16, 20].forEach(i => { // 食指、中指、无名指、小指的指尖
                const d = Math.sqrt(Math.pow(landmarks[i].x - landmarks[0].x, 2) + Math.pow(landmarks[i].y - landmarks[0].y, 2));
                if (d < 0.35) folded++; // 距离手腕过近则认为弯曲
            });

            // 检测捏合手势（拇指和食指指尖距离）
            const dPinch = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));

            // 识别手势
            const isPinch = dPinch < 0.1; // 捏合
            const isFist = folded >= 4; // 拳头
            const isOpen = !isFist && !isPinch; // 张开

            const status = document.getElementById('status-text');

            // 手势响应
            if (isPinch && currentState === STATE.SCATTER) {
                // 捏合手势 - 抓取照片
                if (photoMeshes.length > 0) {
                    targetState = STATE.ZOOM;
                    currentState = STATE.ZOOM;
                    status.innerHTML = "状态: <span style='color:#ffd700'>抓取照片</span>";
                    // 选择最近的照片
                    if (zoomTargetIndex === -1 && photoMeshes.length > 0) {
                        let minDist = Infinity;
                        let bestIdx = 0;
                        const camPos = camera.position;
                        const worldPos = new THREE.Vector3();
                        photoMeshes.forEach((mesh, idx) => {
                            mesh.getWorldPosition(worldPos);
                            const d = worldPos.distanceTo(camPos);
                            if (d < minDist) {
                                minDist = d;
                                bestIdx = idx;
                            }
                        });
                        zoomTargetIndex = bestIdx;
                    }
                } else {
                    status.innerHTML = "状态: <span style='color:#aaa'>请先上传照片</span>";
                }
            } else if (isFist) {
                // 拳头手势 - 聚合成蛋糕
                currentState = STATE.TREE;
                zoomTargetIndex = -1;
                rotationVelocity.x = 0;
                rotationVelocity.y = 0;
                status.innerHTML = "状态: <span style='color:#00ff00'>聚合成蛋糕</span>";
            } else if (isOpen) {
                // 张开手势 - 星云散开
                if (currentState === STATE.ZOOM && !isPinch) {
                    currentState = STATE.SCATTER;
                    zoomTargetIndex = -1;
                } else if (currentState === STATE.TREE) {
                    currentState = STATE.SCATTER;
                    lastHandPos.x = handPos.x;
                    lastHandPos.y = handPos.y;
                }
                status.innerHTML = "状态: <span style='color:#00aaff'>星云散开</span>";
            }
        }

        // 窗口大小改变时的处理函数
        function onWindowResize() {
            const dims = updateDimensions(); // 更新尺寸
            if (dims.width === 0 || dims.height === 0) return; // 避免零尺寸

            camera.aspect = dims.width / dims.height; // 更新相机宽高比
            camera.updateProjectionMatrix(); // 更新投影矩阵

            // 根据屏幕方向调整相机距离
            const isPortrait = dims.height > dims.width; // 是否为竖屏
            const targetZ = isPortrait ? 200 : 140; // 竖屏时相机更远
            if (currentMode === APP_MODE.CAKE) {
                // 平滑过渡相机位置
                new TWEEN.Tween(camera.position).to({ z: targetZ }, 500).easing(TWEEN.Easing.Cubic.Out).start();
            }

            // 更新渲染器和后期处理大小
            renderer.setSize(dims.width, dims.height);
            composer.setSize(dims.width, dims.height);
            composer.passes[1].resolution.set(dims.width, dims.height); // 更新 Bloom 效果分辨率
        }

        // 页面可见性改变时的处理函数
        document.addEventListener("visibilitychange", async () => {
            if (document.visibilityState === "visible") {
                // 页面变为可见时，恢复视频播放
                if (globalVideo && globalVideo.paused) {
                    try {
                        await globalVideo.play(); // 尝试播放视频
                    } catch (e) {
                        startCamera(); // 播放失败则重新启动摄像头
                    }
                }
            }
        });

        // 文件输入事件监听器 - 处理用户上传照片
        document.getElementById('file-input').addEventListener('change', function (e) {
            // setTimeout(() => { startCamera(); }, 600);
            const files = e.target.files;
            if (!files.length) return; // 没有文件则返回

            // 处理每个上传的文件
            for (let i = 0; i < files.length; i++) {
                const reader = new FileReader();
                reader.onload = function (evt) {
                    const img = new Image();
                    img.src = evt.target.result; // 设置图片源为 DataURL
                    img.onload = () => {
                        addPhotoMesh(img); // 图片加载完成后添加到场景
                    }
                };
                reader.readAsDataURL(files[i]); // 读取文件为 DataURL
            }
        });

        // 添加照片网格
        function addPhotoMesh(img) {
            // 创建纹理
            const tex = new THREE.Texture(img);
            tex.needsUpdate = true; // 标记纹理需要更新
            tex.colorSpace = THREE.SRGBColorSpace; // 设置颜色空间

            // 计算照片尺寸（保持比例）
            let w = 4, h = 4;
            if (img.width > img.height) {
                h = 4 * (img.height / img.width); // 横向照片
            } else {
                w = 4 * (img.width / img.height); // 纵向照片
            }

            // 创建材质
            const mat = new THREE.MeshStandardMaterial({
                map: tex,             // 纹理
                side: THREE.DoubleSide, // 双面渲染
                color: new THREE.Color(0.6, 0.6, 0.6), // 基础颜色
                roughness: 0.9,       // 粗糙度
                metalness: 0.0,       // 金属度
                emissive: 0x222222,    // 自发光颜色
                emissiveIntensity: 0.5 // 自发光强度
            });

            // 创建照片网格
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);

            // 创建照片边框
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.2, h + 0.2, 0.1), // 边框几何体
                new THREE.MeshPhysicalMaterial({
                    color: 0xffd700,       // 金色
                    roughness: 0.2,        // 粗糙度
                    metalness: 1.0,        // 金属度
                    emissive: 0xaa6600,     // 自发光颜色
                    emissiveIntensity: 0.2  // 自发光强度
                })
            );
            frame.position.z = -0.06; // 边框在照片后面
            mesh.add(frame); // 添加边框到照片

            // 计算照片在蛋糕上的位置
            const tierIndex = Math.floor(Math.random() * CONFIG.tiers.length); // 随机选择蛋糕层
            const tier = CONFIG.tiers[tierIndex];
            const h_pos = Math.random() * tier.height; // 随机高度
            const r = tier.radius * 1.1; // 半径（稍大于蛋糕层半径）
            const theta = Math.random() * Math.PI * 2; // 随机角度
            const treePos = new THREE.Vector3(r * Math.cos(theta), tier.yBottom + h_pos, r * Math.sin(theta)); // 计算位置

            // 设置照片数据
            mesh.userData = {
                treePos: treePos,                // 蛋糕上的位置
                scatterPos: randomSpherePoint(50), // 散射位置
                baseRot: new THREE.Euler(0, Math.random() * Math.PI, 0) // 基础旋转
            };
            mesh.position.copy(treePos); // 设置初始位置

            // 添加到数组和场景
            photoMeshes.push(mesh);
            mainGroup.add(mesh);
        }

        initThree();
    </script>
</body>

</html>