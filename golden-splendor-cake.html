<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Splendor Cake</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #video {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #ffd700;
            border-radius: 8px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
        }

        #upload-btn {
            position: fixed;
            bottom: 160px;
            right: 20px;
            padding: 10px 15px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10;
            transition: all 0.3s ease;
        }

        #upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }

        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        #start-screen h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #start-btn {
            padding: 15px 30px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #000;
            border: none;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        #start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.6);
        }

        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ffd700;
            z-index: 10;
            max-width: 300px;
        }

        #instructions h3 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        #instructions ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #instructions li {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .control-btn {
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            border: 1px solid #ffd700;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            #video {
                width: 120px;
                height: 90px;
            }

            #upload-btn {
                bottom: 120px;
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            #start-screen h1 {
                font-size: 2rem;
            }

            #start-btn {
                padding: 12px 24px;
                font-size: 1rem;
            }

            #instructions {
                max-width: 250px;
                font-size: 0.8rem;
            }

            #controls {
                flex-direction: column;
                bottom: 130px;
            }

            .control-btn {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js",
                "@tweenjs/tween.js": "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>
    <div id="start-screen">
        <h1>Golden Splendor Cake</h1>
        <button id="start-btn">å¼€å¯ä½“éªŒ</button>
    </div>

    <div id="instructions">
        <h3>æ‰‹åŠ¿æ“ä½œæŒ‡å¼•</h3>
        <ul>
            <li>âœŠ æ¡æ‹³ â†’ ç²’å­èšåˆæˆè›‹ç³•</li>
            <li>ğŸ–ï¸ å¼ å¼€æ‰‹æŒ â†’ ç²’å­çˆ†ç‚¸æ•£å¼€</li>
            <li>ğŸ¤ æåˆ â†’ ç›¸æœºæ¨è¿›æŸ¥çœ‹ç…§ç‰‡</li>
            <li>ğŸ‘‹ æŒ¥æ‰‹ â†’ æ—‹è½¬ 3D åœºæ™¯</li>
        </ul>
    </div>

    <div id="controls">
        <button class="control-btn" id="music-btn">ğŸµ éŸ³ä¹</button>
        <button class="control-btn" id="fullscreen-btn">â›¶ å…¨å±</button>
    </div>

    <video id="video" autoplay muted playsinline></video>
    <button id="upload-btn">ğŸ“· ä¸Šä¼ ç…§ç‰‡</button>
    <input type="file" id="file-input" accept="image/*" style="display: none;">
    <canvas id="canvas"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as TWEEN from '@tweenjs/tween.js';

        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls, composer;
        let particleSystem;
        let cakeParticles = [];
        let floatingParticles = [];
        let goldenSnowParticles = [];
        let stars = [];
        let photoPlane = null;
        let happyBirthdayText = null;
        let currentState = 'cake'; // 'cake' or 'floating'
        let isExperienceStarted = false;
        let isMusicPlaying = false;
        let audioContext = null;
        let analyser = null;
        let dataArray = null;

        // MediaPipe ç›¸å…³å˜é‡
        let handLandmarker;
        let cameraController;
        let isHandDetected = false;
        let lastHandTime = 0;
        const HAND_DETECTION_INTERVAL = 100;

        // åˆå§‹åŒ–å‡½æ•°
        async function init() {
            await initScene();
            initParticles();
            initGoldenSnow();
            initStars();
            initHappyBirthdayText();
            initEventListeners();
            animate();
        }

        // åˆå§‹åŒ–æ‰‹éƒ¨æ£€æµ‹
        async function initHandDetection() {
            try {
                // å¯¼å…¥ MediaPipe Tasks Vision
                const { HandLandmarker, FilesetResolver } = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js');

                // åŠ è½½æ¨¡å‹æ–‡ä»¶
                const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm');
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                        delegate: 'GPU'
                    },
                    runningMode: 'VIDEO',
                    numHands: 2
                });

                // åˆå§‹åŒ–æ‘„åƒå¤´
                const video = document.getElementById('video');
                cameraController = new Camera(video, { width: 640, height: 480 });
                await cameraController.start();

                // å¼€å§‹æ£€æµ‹å¾ªç¯
                detectHands();
            } catch (error) {
                console.error('Error initializing hand detection:', error);
            }
        }

        // æ£€æµ‹æ‰‹éƒ¨å¾ªç¯
        function detectHands() {
            if (handLandmarker && cameraController && isExperienceStarted) {
                const currentTime = Date.now();
                if (currentTime - lastHandTime > HAND_DETECTION_INTERVAL) {
                    const video = document.getElementById('video');
                    const result = handLandmarker.detectForVideo(video, currentTime);
                    processHandResults(result);
                    lastHandTime = currentTime;
                }
            }
            requestAnimationFrame(detectHands);
        }

        // å¤„ç†æ‰‹éƒ¨æ£€æµ‹ç»“æœ
        function processHandResults(results) {
            isHandDetected = results.landmarks && results.landmarks.length > 0;

            if (isHandDetected) {
                // å¤„ç†æ¯åªæ‰‹
                results.landmarks.forEach((landmarks, index) => {
                    // æ£€æµ‹æ‰‹åŠ¿
                    const gesture = detectGesture(landmarks);
                    
                    // æ ¹æ®æ‰‹åŠ¿æ‰§è¡Œæ“ä½œ
                    switch (gesture) {
                        case 'fist':
                            switchToCake();
                            break;
                        case 'open_palm':
                            switchToFloating();
                            break;
                        case 'pinch':
                            zoomCamera();
                            break;
                        case 'wave':
                            rotateScene(landmarks);
                            break;
                    }
                });
            }
        }

        // æ£€æµ‹æ‰‹åŠ¿
        function detectGesture(landmarks) {
            // å…³é”®ç‚¹ç´¢å¼•
            const THUMB_TIP = 4;
            const INDEX_FINGER_TIP = 8;
            const MIDDLE_FINGER_TIP = 12;
            const RING_FINGER_TIP = 16;
            const PINKY_TIP = 20;
            const WRIST = 0;

            // è®¡ç®—æ‰‹æŒ‡æ˜¯å¦å¼¯æ›²
            const isThumbBent = isFingerBent(landmarks, WRIST, THUMB_TIP);
            const isIndexBent = isFingerBent(landmarks, WRIST, INDEX_FINGER_TIP);
            const isMiddleBent = isFingerBent(landmarks, WRIST, MIDDLE_FINGER_TIP);
            const isRingBent = isFingerBent(landmarks, WRIST, RING_FINGER_TIP);
            const isPinkyBent = isFingerBent(landmarks, WRIST, PINKY_TIP);

            // æ¡æ‹³
            if (isThumbBent && isIndexBent && isMiddleBent && isRingBent && isPinkyBent) {
                return 'fist';
            }

            // å¼ å¼€æ‰‹æŒ
            if (!isThumbBent && !isIndexBent && !isMiddleBent && !isRingBent && !isPinkyBent) {
                return 'open_palm';
            }

            // æåˆï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡é è¿‘ï¼‰
            const thumbIndexDistance = getDistance(landmarks[THUMB_TIP], landmarks[INDEX_FINGER_TIP]);
            if (thumbIndexDistance < 0.05) {
                return 'pinch';
            }

            // æŒ¥æ‰‹ï¼ˆæ‰‹æŒå·¦å³ç§»åŠ¨ï¼‰
            // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå‡è®¾å½“æ£€æµ‹åˆ°å¼ å¼€æ‰‹æŒæ—¶è§†ä¸ºæŒ¥æ‰‹
            if (!isThumbBent && !isIndexBent) {
                return 'wave';
            }

            return 'unknown';
        }

        // åˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦å¼¯æ›²
        function isFingerBent(landmarks, wristIndex, tipIndex) {
            const wrist = landmarks[wristIndex];
            const tip = landmarks[tipIndex];
            
            // è®¡ç®—æ‰‹è…•åˆ°æŒ‡å°–çš„è·ç¦»
            const distance = getDistance(wrist, tip);
            
            // ç®€å•åˆ¤æ–­ï¼šå¦‚æœè·ç¦»å°äºé˜ˆå€¼ï¼Œè§†ä¸ºå¼¯æ›²
            return distance < 0.3;
        }

        // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»
        function getDistance(point1, point2) {
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) +
                Math.pow(point1.y - point2.y, 2) +
                Math.pow(point1.z - point2.z, 2)
            );
        }

        // ç›¸æœºæ¨è¿›
        function zoomCamera() {
            if (photoPlane) {
                new Tween(camera.position)
                    .to({ z: 2 }, 500)
                    .easing(Easing.Quadratic.Out)
                    .start();
            }
        }

        // æ—‹è½¬åœºæ™¯
        function rotateScene(landmarks) {
            // è·å–æ‰‹æŒä¸­å¿ƒä½ç½®
            const palmCenter = getPalmCenter(landmarks);
            
            // å°†æ‰‹æŒä½ç½®æ˜ å°„åˆ°åœºæ™¯æ—‹è½¬
            const rotationX = (palmCenter.y - 0.5) * Math.PI / 4;
            const rotationY = (palmCenter.x - 0.5) * Math.PI / 4;
            
            // åº”ç”¨æ—‹è½¬åˆ°ç²’å­ç³»ç»Ÿ
            if (particleSystem) {
                new Tween(particleSystem.rotation)
                    .to({ x: rotationX, y: rotationY }, 300)
                    .easing(Easing.Quadratic.Out)
                    .start();
            }
        }

        // è·å–æ‰‹æŒä¸­å¿ƒä½ç½®
        function getPalmCenter(landmarks) {
            const palmIndices = [0, 1, 2, 5, 9, 13, 17];
            let sumX = 0, sumY = 0, sumZ = 0;
            
            for (const index of palmIndices) {
                sumX += landmarks[index].x;
                sumY += landmarks[index].y;
                sumZ += landmarks[index].z;
            }
            
            return {
                x: sumX / palmIndices.length,
                y: sumY / palmIndices.length,
                z: sumZ / palmIndices.length
            };
        }

        // ç›¸æœºç±»ï¼ˆç®€åŒ–ç‰ˆï¼‰
        class Camera {
            constructor(video, options) {
                this.video = video;
                this.options = options || { width: 640, height: 480 };
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: this.options.width,
                            height: this.options.height,
                            facingMode: 'user'
                        }
                    });
                    this.video.srcObject = stream;
                    return new Promise((resolve) => {
                        this.video.onloadedmetadata = () => {
                            this.video.play();
                            resolve();
                        };
                    });
                } catch (error) {
                    console.error('Error starting camera:', error);
                    throw error;
                }
            }

            stop() {
                if (this.video.srcObject) {
                    const tracks = this.video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    this.video.srcObject = null;
                }
            }
        }

        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            return new Promise((resolve) => {
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a0a);

                // åˆ›å»ºç›¸æœº
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 5;

                // åˆ›å»ºæ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;

                // æ·»åŠ ç¯å…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0xffd700, 1.0, 100);
                pointLight.position.set(0, 2, 0);
                scene.add(pointLight);

                // æ·»åŠ ç¯å¢ƒè´´å›¾
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                const envScene = new RoomEnvironment();
                const envMap = pmremGenerator.fromScene(envScene).texture;
                scene.environment = envMap;
                envScene.dispose();
                pmremGenerator.dispose();

                // åæœŸå¤„ç†
                const renderPass = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85
                );
                bloomPass.threshold = 0.2;
                bloomPass.strength = 1.5;
                bloomPass.radius = 0.5;

                composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);

                // è½¨é“æ§åˆ¶å™¨
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = false;

                // å“åº”çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', onWindowResize);

                resolve();
            });
        }

        // çª—å£å¤§å°å˜åŒ–å¤„ç†
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
        function initParticles() {
            const particleCount = 5000;
            const geometry = new THREE.SphereGeometry(0.02, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x402000,
                emissiveIntensity: 0.3
            });

            particleSystem = new THREE.InstancedMesh(geometry, material, particleCount);
            scene.add(particleSystem);

            // åˆå§‹åŒ–ç²’å­ä½ç½®
            const dummy = new THREE.Object3D();
            for (let i = 0; i < particleCount; i++) {
                // è›‹ç³•å½¢çŠ¶ä½ç½®
                const cakePos = getCakePosition(i, particleCount);
                // æ¼‚æµ®ä½ç½®
                const floatPos = getRandomFloatPosition();
                
                cakeParticles.push(cakePos);
                floatingParticles.push(floatPos);

                // åˆå§‹åŒ–ä¸ºè›‹ç³•å½¢çŠ¶
                dummy.position.copy(cakePos);
                dummy.updateMatrix();
                particleSystem.setMatrixAt(i, dummy.matrix);
            }
            particleSystem.instanceMatrix.needsUpdate = true;
        }

        // è·å–è›‹ç³•å½¢çŠ¶ä½ç½®
        function getCakePosition(index, total) {
            const layers = 3;
            const layerIndex = Math.floor((index / total) * layers);
            const layerRatio = (layerIndex + 1) / layers;
            
            const radius = 1.5 * layerRatio;
            const height = -1 + layerIndex * 0.8;
            
            const angle = (index % (total / layers)) / (total / layers) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            return new THREE.Vector3(x, height, z);
        }

        // è·å–éšæœºæ¼‚æµ®ä½ç½®
        function getRandomFloatPosition() {
            const radius = 3;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            return new THREE.Vector3(x, y, z);
        }

        // åˆå§‹åŒ–é‡‘è‰²é›ªèŠ±
        function initGoldenSnow() {
            const snowCount = 200;
            const geometry = new THREE.SphereGeometry(0.01, 6, 6);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 0.6,
                roughness: 0.4,
                emissive: 0x201000
            });

            for (let i = 0; i < snowCount; i++) {
                const snowflake = new THREE.Mesh(geometry, material);
                snowflake.position.set(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 5 + 2,
                    (Math.random() - 0.5) * 10
                );
                snowflake.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    -Math.random() * 0.02 - 0.01,
                    (Math.random() - 0.5) * 0.01
                );
                scene.add(snowflake);
                goldenSnowParticles.push(snowflake);
            }
        }

        // åˆå§‹åŒ–æ˜Ÿç©º
        function initStars() {
            const starCount = 1000;
            const geometry = new THREE.SphereGeometry(0.005, 4, 4);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for (let i = 0; i < starCount; i++) {
                const star = new THREE.Mesh(geometry, material);
                star.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50
                );
                scene.add(star);
                stars.push(star);
            }
        }

        // åˆå§‹åŒ– "Happy Birthday" æ–‡å­—
        function initHappyBirthdayText() {
            // ä½¿ç”¨ç®€å•çš„ç«‹æ–¹ä½“å‡ ä½•ä½“ä»£æ›¿æ–‡å­—
            const geometry = new THREE.BoxGeometry(3, 0.5, 0.1);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x402000,
                emissiveIntensity: 0.5
            });

            happyBirthdayText = new THREE.Mesh(geometry, material);
            happyBirthdayText.position.set(0, 2, 0);
            scene.add(happyBirthdayText);
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initEventListeners() {
            // å¼€å§‹ä½“éªŒæŒ‰é’®
            document.getElementById('start-btn').addEventListener('click', () => {
                startExperience();
            });

            // ä¸Šä¼ ç…§ç‰‡æŒ‰é’®
            document.getElementById('upload-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            // æ–‡ä»¶ä¸Šä¼ å¤„ç†
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            // éŸ³ä¹æŒ‰é’®
            document.getElementById('music-btn').addEventListener('click', toggleMusic);

            // å…¨å±æŒ‰é’®
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
        }

        // å¼€å§‹ä½“éªŒ
        async function startExperience() {
            isExperienceStarted = true;
            document.getElementById('start-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('start-screen').style.display = 'none';
            }, 500);
            
            // åˆå§‹åŒ–æ‰‹éƒ¨æ£€æµ‹
            await initHandDetection();
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(e.target.result, (texture) => {
                    createPhotoPlane(texture);
                });
            };
            reader.readAsDataURL(file);
        }

        // åˆ›å»ºç…§ç‰‡å¹³é¢
        function createPhotoPlane(texture) {
            if (photoPlane) {
                scene.remove(photoPlane);
                photoPlane.geometry.dispose();
                photoPlane.material.dispose();
            }

            const aspectRatio = texture.image.width / texture.image.height;
            const width = 1.5;
            const height = width / aspectRatio;

            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                metalness: 0.3,
                roughness: 0.7
            });

            photoPlane = new THREE.Mesh(geometry, material);
            photoPlane.position.set(0, 0, 0);
            scene.add(photoPlane);

            // æ·»åŠ é‡‘è‰²è¾¹æ¡†
            const borderGeometry = new THREE.BoxGeometry(width + 0.1, height + 0.1, 0.05);
            const borderMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x402000
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.set(0, 0, -0.03);
            photoPlane.add(border);

            // åˆå§‹çŠ¶æ€ï¼šéšè—ç…§ç‰‡
            if (currentState === 'cake') {
                photoPlane.scale.set(0.1, 0.1, 0.1);
                photoPlane.position.set(0, -2, 0);
            }
        }

        // åˆ‡æ¢éŸ³ä¹
        function toggleMusic() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                setupAudio();
            }

            if (isMusicPlaying) {
                audioContext.suspend();
                document.getElementById('music-btn').textContent = 'ğŸµ éŸ³ä¹';
            } else {
                audioContext.resume();
                document.getElementById('music-btn').textContent = 'ğŸ”‡ é™éŸ³';
            }
            isMusicPlaying = !isMusicPlaying;
        }

        // è®¾ç½®éŸ³é¢‘
        function setupAudio() {
            // åˆ›å»ºæŒ¯è¡å™¨
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);

            // åˆ›å»ºå¢ç›Š
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);

            // åˆ›å»ºåˆ†æå™¨
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            // è¿æ¥èŠ‚ç‚¹
            oscillator.connect(gainNode);
            gainNode.connect(analyser);
            analyser.connect(audioContext.destination);

            // å¯åŠ¨æŒ¯è¡å™¨
            oscillator.start();

            // åˆ›å»ºç®€å•çš„ç”Ÿæ—¥éŸ³ä¹
            const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
            const duration = 0.3;

            for (let i = 0; i < 16; i++) {
                const note = notes[Math.floor(Math.random() * notes.length)];
                const time = audioContext.currentTime + i * duration;
                
                oscillator.frequency.exponentialRampToValueAtTime(
                    note, 
                    time
                );
                
                gainNode.gain.setValueAtTime(0.1, time);
                gainNode.gain.exponentialRampToValueAtTime(
                    0.01, 
                    time + duration
                );
            }
        }

        // åˆ‡æ¢å…¨å±
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // çŠ¶æ€åˆ‡æ¢ï¼šè›‹ç³• -> æ¼‚æµ®
        function switchToFloating() {
            if (currentState === 'floating') return;
            currentState = 'floating';

            // ç²’å­æ•£å¼€åŠ¨ç”»
            const dummy = new THREE.Object3D();
            for (let i = 0; i < cakeParticles.length; i++) {
                const startPos = cakeParticles[i];
                const endPos = floatingParticles[i];

                new TWEEN.Tween(startPos)
                    .to({ x: endPos.x, y: endPos.y, z: endPos.z }, 2000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }

            // ç…§ç‰‡æ˜¾ç¤ºåŠ¨ç”»
            if (photoPlane) {
                new Tween(photoPlane.scale)
                    .to({ x: 1, y: 1, z: 1 }, 1000)
                    .easing(Easing.Quadratic.Out)
                    .start();

                new Tween(photoPlane.position)
                    .to({ x: 0, y: 0, z: 0 }, 1000)
                    .easing(Easing.Quadratic.Out)
                    .start();
            }
        }

        // çŠ¶æ€åˆ‡æ¢ï¼šæ¼‚æµ® -> è›‹ç³•
        function switchToCake() {
            if (currentState === 'cake') return;
            currentState = 'cake';

            // ç²’å­èšåˆåŠ¨ç”»
            const dummy = new THREE.Object3D();
            for (let i = 0; i < cakeParticles.length; i++) {
                const startPos = floatingParticles[i];
                const endPos = cakeParticles[i];

                new Tween(startPos)
                    .to({ x: endPos.x, y: endPos.y, z: endPos.z }, 2000)
                    .easing(Easing.Quadratic.Out)
                    .start();
            }

            // ç…§ç‰‡éšè—åŠ¨ç”»
            if (photoPlane) {
                new Tween(photoPlane.scale)
                    .to({ x: 0.1, y: 0.1, z: 0.1 }, 1000)
                    .easing(Easing.Quadratic.Out)
                    .start();

                new Tween(photoPlane.position)
                    .to({ x: 0, y: -2, z: 0 }, 1000)
                    .easing(Easing.Quadratic.Out)
                    .start();
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            if (isExperienceStarted) {
                // æ›´æ–°æ§åˆ¶å™¨
                controls.update();

                // æ›´æ–°ç²’å­
                updateParticles();
                updateGoldenSnow();
                updateStars();

                // æ›´æ–°æ–‡æœ¬æ—‹è½¬
                if (happyBirthdayText) {
                    happyBirthdayText.rotation.y += 0.01;
                }

                // æ›´æ–°ç…§ç‰‡å¹³é¢
                if (photoPlane && currentState === 'floating') {
                    photoPlane.rotation.y += 0.005;
                }

                // æ›´æ–°éŸ³é¢‘å¯è§†åŒ–ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (analyser && isMusicPlaying) {
                    analyser.getByteFrequencyData(dataArray);
                    // è¿™é‡Œå¯ä»¥æ ¹æ®éŸ³é¢‘æ•°æ®æ›´æ–°è§†è§‰æ•ˆæœ
                }

                // æ¸²æŸ“
                composer.render();
            } else {
                // ä»…æ¸²æŸ“å¯åŠ¨å±å¹•
                renderer.render(scene, camera);
            }
        }

        // æ›´æ–°ç²’å­
        function updateParticles() {
            if (!particleSystem) return;

            const dummy = new THREE.Object3D();
            for (let i = 0; i < cakeParticles.length; i++) {
                const pos = currentState === 'cake' ? cakeParticles[i] : floatingParticles[i];
                dummy.position.copy(pos);
                dummy.updateMatrix();
                particleSystem.setMatrixAt(i, dummy.matrix);
            }
            particleSystem.instanceMatrix.needsUpdate = true;

            // æ›´æ–° Tween
            TWEEN.update();
        }

        // æ›´æ–°é‡‘è‰²é›ªèŠ±
        function updateGoldenSnow() {
            goldenSnowParticles.forEach(snowflake => {
                snowflake.position.add(snowflake.velocity);
                
                // é‡ç½®é›ªèŠ±ä½ç½®
                if (snowflake.position.y < -3) {
                    snowflake.position.y = 5;
                    snowflake.position.x = (Math.random() - 0.5) * 10;
                    snowflake.position.z = (Math.random() - 0.5) * 10;
                }
                
                // æ—‹è½¬é›ªèŠ±
                snowflake.rotation.x += 0.01;
                snowflake.rotation.y += 0.02;
            });
        }

        // æ›´æ–°æ˜Ÿç©º
        function updateStars() {
            stars.forEach(star => {
                star.rotation.x += 0.001;
                star.rotation.y += 0.002;
            });
        }

        // å¯åŠ¨åº”ç”¨
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>