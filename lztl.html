
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子通量|手势控制系统</title>
    <!-- Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://esm.sh/three@0.160.0",
        "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: system-ui, -apple-system, sans-serif; }
        canvas { display: block; }
        .glass { background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.1); }
        .no-select { user-select: none; }
        @keyframes pulse-custom { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .animate-pulse-soft { animation: pulse-custom 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        /* Custom Scrollbar for the picker grid if needed */
        #shape-picker::-webkit-scrollbar { width: 4px; }
        #shape-picker::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }
    </style>
</head>
<body>
    <!-- 隐藏视频追踪 -->
    <div id="video-container" class="fixed bottom-4 right-4 w-48 h-36 rounded-2xl overflow-hidden border-2 border-white/10 opacity-30 hover:opacity-100 transition-opacity z-50 glass">
        <video id="input-video" class="w-full h-full object-cover scale-x-[-1]"></video>
        <div class="absolute top-2 left-3 text-[10px] font-mono tracking-widest text-white/50">追踪画面</div>
    </div>

    <!-- UI Overlay -->
    <div class="fixed inset-0 pointer-events-none flex flex-col justify-between p-6 z-10 no-select">
        <!-- Top Bar -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="space-y-1">
                <h1 class="text-2xl font-black tracking-tighter flex items-center gap-2 text-white">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-cyan-400"><path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-8 0 4 4 0 0 0-8 0 4 4 0 0 1-8 0"></path><circle cx="12" cy="12" r="3"></circle></svg>
                    粒子 <span class="text-cyan-400">通量</span>
                </h1>
                <p class="text-[10px] text-white/40 uppercase tracking-[0.2em]">手势控制系统 3.2</p>
            </div>

            <button id="fullscreen-btn" class="p-3 glass rounded-xl text-white/80 hover:text-white transition-all hover:scale-105 active:scale-95">
                <svg id="fs-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
            </button>
        </div>

        <!-- Gesture Status Toast -->
        <div id="gesture-toast" class="absolute top-24 left-1/2 -translate-x-1/2 px-6 py-2 glass rounded-full text-xs font-medium text-white/80 animate-pulse-soft flex items-center gap-2 border-cyan-500/30">
            <span class="w-1.5 h-1.5 bg-cyan-400 rounded-full"></span>
            出示手来控制扩散
        </div>

        <!-- Controls Panel -->
        <div class="w-full max-w-xs space-y-4 pointer-events-auto">
            <div class="glass rounded-3xl p-6 space-y-6">
                <!-- 形态选择器 -->
                <section class="space-y-3">
                    <div class="flex items-center gap-2 text-white/40 text-[10px] font-bold uppercase tracking-widest">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg>
                        形态模式
                    </div>
                    <div class="grid grid-cols-3 gap-2 overflow-y-auto max-h-48 pr-1" id="shape-picker">
                        <button data-shape="SPHERE" class="shape-btn py-2 text-[10px] rounded-lg border border-cyan-500/50 bg-cyan-500/20 text-cyan-400 transition-all">球体</button>
                        <button data-shape="CUBE" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">立方体</button>
                        <button data-shape="TORUS" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">圆环</button>
                        <button data-shape="HEART" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">心形</button>
                        <button data-shape="SPIRAL" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">螺旋</button>
                        <button data-shape="WAVE" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">波浪</button>
                        <button data-shape="DNA" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">DNA</button>
                        <button data-shape="KNOT" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">结</button>
                        <button data-shape="VORTEX" class="shape-btn py-2 text-[10px] rounded-lg border border-white/10 bg-white/5 text-white/60 hover:bg-white/10 transition-all">漩涡</button>
                    </div>
                </section>

                <!-- 颜色选择 -->
                <section class="space-y-3">
                    <div class="flex items-center gap-2 text-white/40 text-[10px] font-bold uppercase tracking-widest">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg>
                        色调
                    </div>
                    <div class="flex flex-wrap gap-2.5" id="color-picker">
                        <!-- Colors injected via JS -->
                    </div>
                </section>

                <!-- 状态信息 -->
                <section class="pt-4 border-t border-white/5 flex items-center justify-between">
                    <div>
                        <div class="text-[9px] text-white/30 uppercase tracking-[0.2em] mb-1">连接状态</div>
                        <div id="status-text" class="text-[10px] font-bold text-orange-400 flex items-center gap-1.5">
                            <span class="w-1.5 h-1.5 bg-orange-400 rounded-full"></span>
                            扫描中...
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-[9px] text-white/30 uppercase tracking-[0.2em] mb-1">扩散度</div>
                        <div id="spread-val" class="text-[10px] font-mono font-bold text-white">0%</div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- CONSTANTS & CONFIG ---
        const PARTICLE_COUNT = 10000;
        const DEFAULT_COLOR = '#00f2ff';
        const COLORS = ['#00f2ff', '#ff007a', '#7000ff', '#00ff95', '#ffcc00', '#ffffff'];
        const LERP_SPEED = 0.08;
        const MAX_SPREAD_FACTOR = 4.0;
        const ROTATION_SPEED_Y = 0.008; // Increased from 0.002
        const ROTATION_SPEED_X = 0.004; // Increased from 0.001

        let settings = {
            shape: 'SPHERE',
            color: DEFAULT_COLOR,
            spread: 0.2, // 0 to 1
            handDetected: false
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- SHAPE DATA GENERATION ---
        const shapeData = {};

        function generateShapes() {
            const count = PARTICLE_COUNT;
            
            // Sphere
            const sphere = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                sphere[i * 3] = Math.cos(theta) * Math.sin(phi);
                sphere[i * 3 + 1] = Math.sin(theta) * Math.sin(phi);
                sphere[i * 3 + 2] = Math.cos(phi);
            }
            shapeData.SPHERE = sphere;

            // Cube
            const cube = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                cube[i * 3] = (Math.random() - 0.5) * 2.5;
                cube[i * 3 + 1] = (Math.random() - 0.5) * 2.5;
                cube[i * 3 + 2] = (Math.random() - 0.5) * 2.5;
            }
            shapeData.CUBE = cube;

            // Torus
            const torus = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const R = 1.2, r = 0.4;
                torus[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                torus[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                torus[i * 3 + 2] = r * Math.sin(v);
            }
            shapeData.TORUS = torus;

            // Heart
            const heart = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                heart[i * 3] = 0.5 * (1.6 * Math.pow(Math.sin(t), 3));
                heart[i * 3 + 1] = 0.5 * (1.3 * Math.cos(t) - 0.5 * Math.cos(2 * t) - 0.2 * Math.cos(3 * t) - 0.1 * Math.cos(4 * t));
                heart[i * 3 + 2] = (Math.random() - 0.5) * 0.4;
            }
            shapeData.HEART = heart;

            // Spiral
            const spiral = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const angle = 0.1 * i;
                const radius = 0.005 * i;
                spiral[i * 3] = radius * Math.cos(angle) * 0.5;
                spiral[i * 3 + 1] = radius * Math.sin(angle) * 0.5;
                spiral[i * 3 + 2] = (i / count - 0.5) * 4;
            }
            shapeData.SPIRAL = spiral;

            // Wave
            const wave = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 4;
                const y = (Math.random() - 0.5) * 4;
                wave[i * 3] = x;
                wave[i * 3 + 1] = Math.sin(x * 2) * Math.cos(y * 2) * 0.5;
                wave[i * 3 + 2] = y;
            }
            shapeData.WAVE = wave;

            // DNA Helix
            const dna = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 12;
                const r = 1.0;
                const strand = i % 2 === 0 ? 0 : Math.PI;
                dna[i * 3] = r * Math.cos(t + strand);
                dna[i * 3 + 1] = r * Math.sin(t + strand);
                dna[i * 3 + 2] = (i / count - 0.5) * 8;
            }
            shapeData.DNA = dna;

            // Torus Knot
            const knot = new Float32Array(count * 3);
            const p = 2, q = 3;
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const r_knot = Math.cos(q * t) + 2;
                knot[i * 3] = r_knot * Math.cos(p * t) * 0.6;
                knot[i * 3 + 1] = r_knot * Math.sin(p * t) * 0.6;
                knot[i * 3 + 2] = -Math.sin(q * t) * 0.6;
            }
            shapeData.KNOT = knot;

            // Vortex
            const vortex = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const r_v = Math.pow(Math.random(), 0.5) * 4;
                const angle_v = r_v * 5 + Math.random() * 0.5;
                vortex[i * 3] = Math.cos(angle_v) * r_v;
                vortex[i * 3 + 1] = Math.sin(angle_v) * r_v;
                vortex[i * 3 + 2] = (Math.random() - 0.5) * r_v * 0.5;
            }
            shapeData.VORTEX = vortex;
        }

        generateShapes();

        // --- PARTICLES ENGINE ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const currentPos = new Float32Array(PARTICLE_COUNT * 3);
        
        // Initial state
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            currentPos[i] = shapeData.SPHERE[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
        
        const material = new THREE.PointsMaterial({
            color: new THREE.Color(settings.color),
            size: 0.045,
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- MEDIAPIPE HAND TRACKING ---
        const videoElement = document.getElementById('input-video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults((results) => {
            const statusText = document.getElementById('status-text');
            const spreadVal = document.getElementById('spread-val');
            const toast = document.getElementById('gesture-toast');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4];
                const index = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumb.x - index.x, 2) + 
                    Math.pow(thumb.y - index.y, 2)
                );

                // Map distance to spread (approx range 0.05 to 0.3)
                const targetSpread = Math.min(Math.max((distance - 0.04) / 0.25, 0), 1);
                settings.spread = targetSpread;
                settings.handDetected = true;

                statusText.innerHTML = '<span class="w-1.5 h-1.5 bg-green-400 rounded-full animate-pulse"></span>已连接';
                statusText.className = 'text-[10px] font-bold text-green-400 flex items-center gap-1.5';
                spreadVal.innerText = `${(targetSpread * 100).toFixed(0)}%`;
                toast.classList.add('opacity-0');
            } else {
                settings.handDetected = false;
                // Slowly return to default spread
                settings.spread += (0.2 - settings.spread) * 0.05;
                statusText.innerHTML = '<span class="w-1.5 h-1.5 bg-orange-400 rounded-full"></span>扫描中...';
                statusText.className = 'text-[10px] font-bold text-orange-400 flex items-center gap-1.5';
                toast.classList.remove('opacity-0');
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        });
        cameraFeed.start();

        // --- INTERACTION LOGIC ---
        const colorContainer = document.getElementById('color-picker');
        COLORS.forEach(c => {
            const btn = document.createElement('button');
            btn.className = 'w-7 h-7 rounded-full border-2 border-transparent transition-all hover:scale-110';
            btn.style.backgroundColor = c;
            if (c === settings.color) btn.classList.add('border-white', 'scale-110');
            btn.onclick = () => {
                settings.color = c;
                material.color.set(c);
                document.querySelectorAll('#color-picker button').forEach(b => b.classList.remove('border-white', 'scale-110'));
                btn.classList.add('border-white', 'scale-110');
            };
            colorContainer.appendChild(btn);
        });

        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.onclick = () => {
                settings.shape = btn.dataset.shape;
                document.querySelectorAll('.shape-btn').forEach(b => {
                    b.classList.replace('border-cyan-500/50', 'border-white/10');
                    b.classList.replace('bg-cyan-500/20', 'bg-white/5');
                    b.classList.replace('text-cyan-400', 'text-white/60');
                });
                btn.classList.replace('border-white/10', 'border-cyan-500/50');
                btn.classList.replace('bg-white/5', 'bg-cyan-500/20');
                btn.classList.replace('text-white/60', 'text-cyan-400');
            };
        });

        document.getElementById('fullscreen-btn').onclick = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        };

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;
            const targetData = shapeData[settings.shape];
            const scale = 1.0 + (settings.spread * MAX_SPREAD_FACTOR);
            const posAttr = geometry.attributes.position.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // Target with minor vibration
                const vibration = Math.sin(time * 5 + i) * 0.012;
                const tx = targetData[i3] * scale + vibration;
                const ty = targetData[i3 + 1] * scale + vibration;
                const tz = targetData[i3 + 2] * scale + vibration;

                // Smoothly lerp towards target
                posAttr[i3] += (tx - posAttr[i3]) * LERP_SPEED;
                posAttr[i3 + 1] += (ty - posAttr[i3 + 1]) * LERP_SPEED;
                posAttr[i3 + 2] += (tz - posAttr[i3 + 2]) * LERP_SPEED;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // Auto-rotate the whole system - Increased speeds as requested
            points.rotation.y += ROTATION_SPEED_Y;
            points.rotation.x += ROTATION_SPEED_X;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
